/* automatically generated by rust-bindgen 0.71.1 */

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Scope {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct KleinResult {
    pub errorMessage: *mut ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of KleinResult"][::std::mem::size_of::<KleinResult>() - 8usize];
    ["Alignment of KleinResult"][::std::mem::align_of::<KleinResult>() - 8usize];
    ["Offset of field: KleinResult::errorMessage"][::std::mem::offset_of!(KleinResult, errorMessage) - 0usize];
};
pub const TokenType_TOKEN_TYPE_KEYWORD_AND: TokenType = 0;
pub const TokenType_TOKEN_TYPE_KEYWORD_DO: TokenType = 1;
pub const TokenType_TOKEN_TYPE_KEYWORD_ELSE: TokenType = 2;
pub const TokenType_TOKEN_TYPE_KEYWORD_FOR: TokenType = 3;
pub const TokenType_TOKEN_TYPE_KEYWORD_FUNCTION: TokenType = 4;
pub const TokenType_TOKEN_TYPE_KEYWORD_IF: TokenType = 5;
pub const TokenType_TOKEN_TYPE_KEYWORD_IN: TokenType = 6;
pub const TokenType_TOKEN_TYPE_KEYWORD_LET: TokenType = 7;
pub const TokenType_TOKEN_TYPE_KEYWORD_NOT: TokenType = 8;
pub const TokenType_TOKEN_TYPE_KEYWORD_OR: TokenType = 9;
pub const TokenType_TOKEN_TYPE_KEYWORD_TYPE: TokenType = 10;
pub const TokenType_TOKEN_TYPE_KEYWORD_WHILE: TokenType = 11;
pub const TokenType_TOKEN_TYPE_KEYWORD_RETURN: TokenType = 12;
pub const TokenType_TOKEN_TYPE_LEFT_BRACE: TokenType = 13;
pub const TokenType_TOKEN_TYPE_LEFT_BRACKET: TokenType = 14;
pub const TokenType_TOKEN_TYPE_LEFT_PARENTHESIS: TokenType = 15;
pub const TokenType_TOKEN_TYPE_RIGHT_BRACE: TokenType = 16;
pub const TokenType_TOKEN_TYPE_RIGHT_BRACKET: TokenType = 17;
pub const TokenType_TOKEN_TYPE_RIGHT_PARENTHESIS: TokenType = 18;
pub const TokenType_TOKEN_TYPE_ASTERISK: TokenType = 19;
pub const TokenType_TOKEN_TYPE_FORWARD_SLASH: TokenType = 20;
pub const TokenType_TOKEN_TYPE_LESS_THAN: TokenType = 21;
pub const TokenType_TOKEN_TYPE_GREATER_THAN: TokenType = 22;
pub const TokenType_TOKEN_TYPE_LESS_THAN_OR_EQUAL_TO: TokenType = 23;
pub const TokenType_TOKEN_TYPE_GREATER_THAN_OR_EQUAL_TO: TokenType = 24;
pub const TokenType_TOKEN_TYPE_DOUBLE_EQUALS: TokenType = 25;
pub const TokenType_TOKEN_TYPE_NOT_EQUAL: TokenType = 26;
pub const TokenType_TOKEN_TYPE_CARET: TokenType = 27;
pub const TokenType_TOKEN_TYPE_COLON: TokenType = 28;
pub const TokenType_TOKEN_TYPE_COMMA: TokenType = 29;
pub const TokenType_TOKEN_TYPE_DOT: TokenType = 30;
pub const TokenType_TOKEN_TYPE_EQUALS: TokenType = 31;
pub const TokenType_TOKEN_TYPE_MINUS: TokenType = 32;
pub const TokenType_TOKEN_TYPE_PLUS: TokenType = 33;
pub const TokenType_TOKEN_TYPE_SEMICOLON: TokenType = 34;
pub const TokenType_TOKEN_TYPE_STRING: TokenType = 35;
pub const TokenType_TOKEN_TYPE_NUMBER: TokenType = 36;
pub const TokenType_TOKEN_TYPE_IDENTIFIER: TokenType = 37;
pub const TokenType_TOKEN_TYPE_WHITESPACE: TokenType = 38;
pub const TokenType_TOKEN_TYPE_COMMENT: TokenType = 39;
pub type TokenType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Token {
    pub type_: TokenType,
    pub value: *mut ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Token"][::std::mem::size_of::<Token>() - 16usize];
    ["Alignment of Token"][::std::mem::align_of::<Token>() - 8usize];
    ["Offset of field: Token::type_"][::std::mem::offset_of!(Token, type_) - 0usize];
    ["Offset of field: Token::value"][::std::mem::offset_of!(Token, value) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TokenList {
    pub size: ::std::os::raw::c_ulong,
    pub capacity: ::std::os::raw::c_ulong,
    pub data: *mut Token,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of TokenList"][::std::mem::size_of::<TokenList>() - 24usize];
    ["Alignment of TokenList"][::std::mem::align_of::<TokenList>() - 8usize];
    ["Offset of field: TokenList::size"][::std::mem::offset_of!(TokenList, size) - 0usize];
    ["Offset of field: TokenList::capacity"][::std::mem::offset_of!(TokenList, capacity) - 8usize];
    ["Offset of field: TokenList::data"][::std::mem::offset_of!(TokenList, data) - 16usize];
};
unsafe extern "C" {
    pub fn emptyTokenList(output: *mut TokenList) -> KleinResult;
}
unsafe extern "C" {
    pub fn emptyHeapTokenList(output: *mut *mut TokenList) -> KleinResult;
}
unsafe extern "C" {
    pub fn appendToTokenList(list: *mut TokenList, value: Token) -> KleinResult;
}
unsafe extern "C" {
    pub fn prependToTokenList(list: *mut TokenList, value: Token) -> KleinResult;
}
unsafe extern "C" {
    pub fn isTokenListEmpty(list: TokenList) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn popTokenList(list: *mut TokenList) -> KleinResult;
}
unsafe extern "C" {
    pub fn getFromTokenListUnchecked(list: TokenList, index: ::std::os::raw::c_ulong) -> Token;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TypeLiteralData {
    pub identifier: *mut ::std::os::raw::c_char,
    pub function: *mut Function,
    pub typeDeclaration: *mut TypeDeclaration,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of TypeLiteralData"][::std::mem::size_of::<TypeLiteralData>() - 8usize];
    ["Alignment of TypeLiteralData"][::std::mem::align_of::<TypeLiteralData>() - 8usize];
    ["Offset of field: TypeLiteralData::identifier"][::std::mem::offset_of!(TypeLiteralData, identifier) - 0usize];
    ["Offset of field: TypeLiteralData::function"][::std::mem::offset_of!(TypeLiteralData, function) - 0usize];
    ["Offset of field: TypeLiteralData::typeDeclaration"][::std::mem::offset_of!(TypeLiteralData, typeDeclaration) - 0usize];
};
pub const TypeLiteralType_TYPE_LITERAL_FUNCTION: TypeLiteralType = 0;
pub const TypeLiteralType_TYPE_LITERAL_IDENTIFIER: TypeLiteralType = 1;
pub const TypeLiteralType_TYPE_LITERAL_TYPE_DECLARATION: TypeLiteralType = 2;
pub type TypeLiteralType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TypeLiteral {
    pub data: TypeLiteralData,
    pub type_: TypeLiteralType,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of TypeLiteral"][::std::mem::size_of::<TypeLiteral>() - 16usize];
    ["Alignment of TypeLiteral"][::std::mem::align_of::<TypeLiteral>() - 8usize];
    ["Offset of field: TypeLiteral::data"][::std::mem::offset_of!(TypeLiteral, data) - 0usize];
    ["Offset of field: TypeLiteral::type_"][::std::mem::offset_of!(TypeLiteral, type_) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TypeList {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TypeData {
    #[doc = " A union type, also known as an arithmetic sum type. This represents\n a choice between multiple types."]
    pub typeUnion: *mut TypeList,
    #[doc = " A single, literal type, such as a function, identifier, etc."]
    pub literal: TypeLiteral,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of TypeData"][::std::mem::size_of::<TypeData>() - 16usize];
    ["Alignment of TypeData"][::std::mem::align_of::<TypeData>() - 8usize];
    ["Offset of field: TypeData::typeUnion"][::std::mem::offset_of!(TypeData, typeUnion) - 0usize];
    ["Offset of field: TypeData::literal"][::std::mem::offset_of!(TypeData, literal) - 0usize];
};
pub const TypeType_TYPE_UNION: TypeType = 0;
pub const TypeType_TYPE_LITERAL: TypeType = 1;
pub type TypeType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Type {
    pub data: TypeData,
    pub type_: TypeType,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Type"][::std::mem::size_of::<Type>() - 24usize];
    ["Alignment of Type"][::std::mem::align_of::<Type>() - 8usize];
    ["Offset of field: Type::data"][::std::mem::offset_of!(Type, data) - 0usize];
    ["Offset of field: Type::type_"][::std::mem::offset_of!(Type, type_) - 16usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Block {
    pub statements: *mut StatementList,
    pub innerScope: *mut Scope,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Block"][::std::mem::size_of::<Block>() - 16usize];
    ["Alignment of Block"][::std::mem::align_of::<Block>() - 8usize];
    ["Offset of field: Block::statements"][::std::mem::offset_of!(Block, statements) - 0usize];
    ["Offset of field: Block::innerScope"][::std::mem::offset_of!(Block, innerScope) - 8usize];
};
pub const ExpressionType_EXPRESSION_BOOLEAN: ExpressionType = 0;
pub const ExpressionType_EXPRESSION_BINARY: ExpressionType = 1;
pub const ExpressionType_EXPRESSION_FUNCTION: ExpressionType = 2;
pub const ExpressionType_EXPRESSION_BLOCK: ExpressionType = 3;
pub const ExpressionType_EXPRESSION_UNARY: ExpressionType = 4;
pub const ExpressionType_EXPRESSION_IDENTIFIER: ExpressionType = 5;
pub const ExpressionType_EXPRESSION_BUILTIN_FUNCTION: ExpressionType = 6;
pub const ExpressionType_EXPRESSION_OBJECT: ExpressionType = 7;
pub const ExpressionType_EXPRESSION_FOR_LOOP: ExpressionType = 8;
pub const ExpressionType_EXPRESSION_WHILE_LOOP: ExpressionType = 9;
pub const ExpressionType_EXPRESSION_STRING: ExpressionType = 10;
pub const ExpressionType_EXPRESSION_NUMBER: ExpressionType = 11;
pub const ExpressionType_EXPRESSION_LIST: ExpressionType = 12;
pub const ExpressionType_EXPRESSION_IF: ExpressionType = 13;
pub type ExpressionType = ::std::os::raw::c_uint;
#[doc = " A parameter in a function expression."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Parameter {
    #[doc = " The name of the parameter."]
    pub name: *mut ::std::os::raw::c_char,
    #[doc = " The type of the parameter."]
    pub type_: Type,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Parameter"][::std::mem::size_of::<Parameter>() - 32usize];
    ["Alignment of Parameter"][::std::mem::align_of::<Parameter>() - 8usize];
    ["Offset of field: Parameter::name"][::std::mem::offset_of!(Parameter, name) - 0usize];
    ["Offset of field: Parameter::type_"][::std::mem::offset_of!(Parameter, type_) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ParameterList {
    pub size: ::std::os::raw::c_ulong,
    pub capacity: ::std::os::raw::c_ulong,
    pub data: *mut Parameter,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ParameterList"][::std::mem::size_of::<ParameterList>() - 24usize];
    ["Alignment of ParameterList"][::std::mem::align_of::<ParameterList>() - 8usize];
    ["Offset of field: ParameterList::size"][::std::mem::offset_of!(ParameterList, size) - 0usize];
    ["Offset of field: ParameterList::capacity"][::std::mem::offset_of!(ParameterList, capacity) - 8usize];
    ["Offset of field: ParameterList::data"][::std::mem::offset_of!(ParameterList, data) - 16usize];
};
unsafe extern "C" {
    pub fn emptyParameterList(output: *mut ParameterList) -> KleinResult;
}
unsafe extern "C" {
    pub fn emptyHeapParameterList(output: *mut *mut ParameterList) -> KleinResult;
}
unsafe extern "C" {
    pub fn appendToParameterList(list: *mut ParameterList, value: Parameter) -> KleinResult;
}
unsafe extern "C" {
    pub fn prependToParameterList(list: *mut ParameterList, value: Parameter) -> KleinResult;
}
unsafe extern "C" {
    pub fn isParameterListEmpty(list: ParameterList) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn popParameterList(list: *mut ParameterList) -> KleinResult;
}
unsafe extern "C" {
    pub fn getFromParameterListUnchecked(list: ParameterList, index: ::std::os::raw::c_ulong) -> Parameter;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Function {
    #[doc = " The parameters of this function. This `List` contains elements of\n type `Parameter`."]
    pub parameters: ParameterList,
    #[doc = " The return type of this function."]
    pub returnType: Type,
    #[doc = " The body of this function."]
    pub body: Block,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Function"][::std::mem::size_of::<Function>() - 64usize];
    ["Alignment of Function"][::std::mem::align_of::<Function>() - 8usize];
    ["Offset of field: Function::parameters"][::std::mem::offset_of!(Function, parameters) - 0usize];
    ["Offset of field: Function::returnType"][::std::mem::offset_of!(Function, returnType) - 24usize];
    ["Offset of field: Function::body"][::std::mem::offset_of!(Function, body) - 48usize];
};
pub const BinaryOperation_BINARY_OPERATION_ASSIGN: BinaryOperation = 0;
pub const BinaryOperation_BINARY_OPERATION_PLUS: BinaryOperation = 1;
pub const BinaryOperation_BINARY_OPERATION_MINUS: BinaryOperation = 2;
pub const BinaryOperation_BINARY_OPERATION_TIMES: BinaryOperation = 3;
pub const BinaryOperation_BINARY_OPERATION_DIVIDE: BinaryOperation = 4;
pub const BinaryOperation_BINARY_OPERATION_POWER: BinaryOperation = 5;
pub const BinaryOperation_BINARY_OPERATION_AND: BinaryOperation = 6;
pub const BinaryOperation_BINARY_OPERATION_OR: BinaryOperation = 7;
pub const BinaryOperation_BINARY_OPERATION_DOT: BinaryOperation = 8;
pub const BinaryOperation_BINARY_OPERATION_LESS_THAN: BinaryOperation = 9;
pub const BinaryOperation_BINARY_OPERATION_GREATER_THAN: BinaryOperation = 10;
pub const BinaryOperation_BINARY_OPERATION_LESS_THAN_OR_EQUAL_TO: BinaryOperation = 11;
pub const BinaryOperation_BINARY_OPERATION_GREATER_THAN_OR_EQUAL_TO: BinaryOperation = 12;
pub const BinaryOperation_BINARY_OPERATION_EQUAL: BinaryOperation = 13;
pub type BinaryOperation = ::std::os::raw::c_uint;
pub const UnaryOperationType_UNARY_OPERATION_NOT: UnaryOperationType = 0;
pub const UnaryOperationType_UNARY_OPERATION_FUNCTION_CALL: UnaryOperationType = 1;
pub const UnaryOperationType_UNARY_OPERATION_INDEX: UnaryOperationType = 2;
pub type UnaryOperationType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TypeDeclaration {
    pub fields: ParameterList,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of TypeDeclaration"][::std::mem::size_of::<TypeDeclaration>() - 24usize];
    ["Alignment of TypeDeclaration"][::std::mem::align_of::<TypeDeclaration>() - 8usize];
    ["Offset of field: TypeDeclaration::fields"][::std::mem::offset_of!(TypeDeclaration, fields) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union ExpressionData {
    #[doc = " A literal number expression."]
    pub number: f64,
    #[doc = " A block expression."]
    pub block: *mut Block,
    pub boolean: ::std::os::raw::c_int,
    #[doc = " A literal number expression."]
    pub function: Function,
    pub unary: *mut UnaryExpression,
    pub identifier: *mut ::std::os::raw::c_char,
    #[doc = " A binary expression."]
    pub binary: *mut BinaryExpression,
    pub typeDeclaration: TypeDeclaration,
    pub object: *mut Object,
    pub forLoop: *mut ForLoop,
    pub whileLoop: *mut WhileLoop,
    pub list: *mut ExpressionList,
    pub string: *mut ::std::os::raw::c_char,
    pub ifExpression: *mut IfExpressionList,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ExpressionData"][::std::mem::size_of::<ExpressionData>() - 64usize];
    ["Alignment of ExpressionData"][::std::mem::align_of::<ExpressionData>() - 8usize];
    ["Offset of field: ExpressionData::number"][::std::mem::offset_of!(ExpressionData, number) - 0usize];
    ["Offset of field: ExpressionData::block"][::std::mem::offset_of!(ExpressionData, block) - 0usize];
    ["Offset of field: ExpressionData::boolean"][::std::mem::offset_of!(ExpressionData, boolean) - 0usize];
    ["Offset of field: ExpressionData::function"][::std::mem::offset_of!(ExpressionData, function) - 0usize];
    ["Offset of field: ExpressionData::unary"][::std::mem::offset_of!(ExpressionData, unary) - 0usize];
    ["Offset of field: ExpressionData::identifier"][::std::mem::offset_of!(ExpressionData, identifier) - 0usize];
    ["Offset of field: ExpressionData::binary"][::std::mem::offset_of!(ExpressionData, binary) - 0usize];
    ["Offset of field: ExpressionData::typeDeclaration"][::std::mem::offset_of!(ExpressionData, typeDeclaration) - 0usize];
    ["Offset of field: ExpressionData::object"][::std::mem::offset_of!(ExpressionData, object) - 0usize];
    ["Offset of field: ExpressionData::forLoop"][::std::mem::offset_of!(ExpressionData, forLoop) - 0usize];
    ["Offset of field: ExpressionData::whileLoop"][::std::mem::offset_of!(ExpressionData, whileLoop) - 0usize];
    ["Offset of field: ExpressionData::list"][::std::mem::offset_of!(ExpressionData, list) - 0usize];
    ["Offset of field: ExpressionData::string"][::std::mem::offset_of!(ExpressionData, string) - 0usize];
    ["Offset of field: ExpressionData::ifExpression"][::std::mem::offset_of!(ExpressionData, ifExpression) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Expression {
    pub type_: ExpressionType,
    pub data: ExpressionData,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Expression"][::std::mem::size_of::<Expression>() - 72usize];
    ["Alignment of Expression"][::std::mem::align_of::<Expression>() - 8usize];
    ["Offset of field: Expression::type_"][::std::mem::offset_of!(Expression, type_) - 0usize];
    ["Offset of field: Expression::data"][::std::mem::offset_of!(Expression, data) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExpressionList {
    pub size: ::std::os::raw::c_ulong,
    pub capacity: ::std::os::raw::c_ulong,
    pub data: *mut Expression,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ExpressionList"][::std::mem::size_of::<ExpressionList>() - 24usize];
    ["Alignment of ExpressionList"][::std::mem::align_of::<ExpressionList>() - 8usize];
    ["Offset of field: ExpressionList::size"][::std::mem::offset_of!(ExpressionList, size) - 0usize];
    ["Offset of field: ExpressionList::capacity"][::std::mem::offset_of!(ExpressionList, capacity) - 8usize];
    ["Offset of field: ExpressionList::data"][::std::mem::offset_of!(ExpressionList, data) - 16usize];
};
unsafe extern "C" {
    pub fn emptyExpressionList(output: *mut ExpressionList) -> KleinResult;
}
unsafe extern "C" {
    pub fn emptyHeapExpressionList(output: *mut *mut ExpressionList) -> KleinResult;
}
unsafe extern "C" {
    pub fn appendToExpressionList(list: *mut ExpressionList, value: Expression) -> KleinResult;
}
unsafe extern "C" {
    pub fn prependToExpressionList(list: *mut ExpressionList, value: Expression) -> KleinResult;
}
unsafe extern "C" {
    pub fn isExpressionListEmpty(list: ExpressionList) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn popExpressionList(list: *mut ExpressionList) -> KleinResult;
}
unsafe extern "C" {
    pub fn getFromExpressionListUnchecked(list: ExpressionList, index: ::std::os::raw::c_ulong) -> Expression;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct BinaryExpression {
    pub left: Expression,
    pub operation: BinaryOperation,
    pub right: Expression,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of BinaryExpression"][::std::mem::size_of::<BinaryExpression>() - 152usize];
    ["Alignment of BinaryExpression"][::std::mem::align_of::<BinaryExpression>() - 8usize];
    ["Offset of field: BinaryExpression::left"][::std::mem::offset_of!(BinaryExpression, left) - 0usize];
    ["Offset of field: BinaryExpression::operation"][::std::mem::offset_of!(BinaryExpression, operation) - 72usize];
    ["Offset of field: BinaryExpression::right"][::std::mem::offset_of!(BinaryExpression, right) - 80usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union UnaryOperationData {
    pub functionCall: ExpressionList,
    pub index: Expression,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of UnaryOperationData"][::std::mem::size_of::<UnaryOperationData>() - 72usize];
    ["Alignment of UnaryOperationData"][::std::mem::align_of::<UnaryOperationData>() - 8usize];
    ["Offset of field: UnaryOperationData::functionCall"][::std::mem::offset_of!(UnaryOperationData, functionCall) - 0usize];
    ["Offset of field: UnaryOperationData::index"][::std::mem::offset_of!(UnaryOperationData, index) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct UnaryOperation {
    pub data: UnaryOperationData,
    pub type_: UnaryOperationType,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of UnaryOperation"][::std::mem::size_of::<UnaryOperation>() - 80usize];
    ["Alignment of UnaryOperation"][::std::mem::align_of::<UnaryOperation>() - 8usize];
    ["Offset of field: UnaryOperation::data"][::std::mem::offset_of!(UnaryOperation, data) - 0usize];
    ["Offset of field: UnaryOperation::type_"][::std::mem::offset_of!(UnaryOperation, type_) - 72usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct UnaryExpression {
    pub expression: Expression,
    pub operation: UnaryOperation,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of UnaryExpression"][::std::mem::size_of::<UnaryExpression>() - 152usize];
    ["Alignment of UnaryExpression"][::std::mem::align_of::<UnaryExpression>() - 8usize];
    ["Offset of field: UnaryExpression::expression"][::std::mem::offset_of!(UnaryExpression, expression) - 0usize];
    ["Offset of field: UnaryExpression::operation"][::std::mem::offset_of!(UnaryExpression, operation) - 72usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Field {
    pub name: *mut ::std::os::raw::c_char,
    pub value: Expression,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Field"][::std::mem::size_of::<Field>() - 80usize];
    ["Alignment of Field"][::std::mem::align_of::<Field>() - 8usize];
    ["Offset of field: Field::name"][::std::mem::offset_of!(Field, name) - 0usize];
    ["Offset of field: Field::value"][::std::mem::offset_of!(Field, value) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FieldList {
    pub size: ::std::os::raw::c_ulong,
    pub capacity: ::std::os::raw::c_ulong,
    pub data: *mut Field,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FieldList"][::std::mem::size_of::<FieldList>() - 24usize];
    ["Alignment of FieldList"][::std::mem::align_of::<FieldList>() - 8usize];
    ["Offset of field: FieldList::size"][::std::mem::offset_of!(FieldList, size) - 0usize];
    ["Offset of field: FieldList::capacity"][::std::mem::offset_of!(FieldList, capacity) - 8usize];
    ["Offset of field: FieldList::data"][::std::mem::offset_of!(FieldList, data) - 16usize];
};
unsafe extern "C" {
    pub fn emptyFieldList(output: *mut FieldList) -> KleinResult;
}
unsafe extern "C" {
    pub fn emptyHeapFieldList(output: *mut *mut FieldList) -> KleinResult;
}
unsafe extern "C" {
    pub fn appendToFieldList(list: *mut FieldList, value: Field) -> KleinResult;
}
unsafe extern "C" {
    pub fn prependToFieldList(list: *mut FieldList, value: Field) -> KleinResult;
}
unsafe extern "C" {
    pub fn isFieldListEmpty(list: FieldList) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn popFieldList(list: *mut FieldList) -> KleinResult;
}
unsafe extern "C" {
    pub fn getFromFieldListUnchecked(list: FieldList, index: ::std::os::raw::c_ulong) -> Field;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Object {
    pub fields: FieldList,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Object"][::std::mem::size_of::<Object>() - 24usize];
    ["Alignment of Object"][::std::mem::align_of::<Object>() - 8usize];
    ["Offset of field: Object::fields"][::std::mem::offset_of!(Object, fields) - 0usize];
};
pub const StatementType_STATEMENT_DECLARATION: StatementType = 0;
pub const StatementType_STATEMENT_EXPRESSION: StatementType = 1;
pub const StatementType_STATEMENT_RETURN: StatementType = 2;
pub type StatementType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Declaration {
    pub name: *mut ::std::os::raw::c_char,
    pub type_: *mut Type,
    pub value: Expression,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Declaration"][::std::mem::size_of::<Declaration>() - 88usize];
    ["Alignment of Declaration"][::std::mem::align_of::<Declaration>() - 8usize];
    ["Offset of field: Declaration::name"][::std::mem::offset_of!(Declaration, name) - 0usize];
    ["Offset of field: Declaration::type_"][::std::mem::offset_of!(Declaration, type_) - 8usize];
    ["Offset of field: Declaration::value"][::std::mem::offset_of!(Declaration, value) - 16usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DeclarationList {
    pub size: ::std::os::raw::c_ulong,
    pub capacity: ::std::os::raw::c_ulong,
    pub data: *mut Declaration,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of DeclarationList"][::std::mem::size_of::<DeclarationList>() - 24usize];
    ["Alignment of DeclarationList"][::std::mem::align_of::<DeclarationList>() - 8usize];
    ["Offset of field: DeclarationList::size"][::std::mem::offset_of!(DeclarationList, size) - 0usize];
    ["Offset of field: DeclarationList::capacity"][::std::mem::offset_of!(DeclarationList, capacity) - 8usize];
    ["Offset of field: DeclarationList::data"][::std::mem::offset_of!(DeclarationList, data) - 16usize];
};
unsafe extern "C" {
    pub fn emptyDeclarationList(output: *mut DeclarationList) -> KleinResult;
}
unsafe extern "C" {
    pub fn emptyHeapDeclarationList(output: *mut *mut DeclarationList) -> KleinResult;
}
unsafe extern "C" {
    pub fn appendToDeclarationList(list: *mut DeclarationList, value: Declaration) -> KleinResult;
}
unsafe extern "C" {
    pub fn prependToDeclarationList(list: *mut DeclarationList, value: Declaration) -> KleinResult;
}
unsafe extern "C" {
    pub fn isDeclarationListEmpty(list: DeclarationList) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn popDeclarationList(list: *mut DeclarationList) -> KleinResult;
}
unsafe extern "C" {
    pub fn getFromDeclarationListUnchecked(list: DeclarationList, index: ::std::os::raw::c_ulong) -> Declaration;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union StatementData {
    pub declaration: Declaration,
    pub expression: Expression,
    pub returnExpression: Expression,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of StatementData"][::std::mem::size_of::<StatementData>() - 88usize];
    ["Alignment of StatementData"][::std::mem::align_of::<StatementData>() - 8usize];
    ["Offset of field: StatementData::declaration"][::std::mem::offset_of!(StatementData, declaration) - 0usize];
    ["Offset of field: StatementData::expression"][::std::mem::offset_of!(StatementData, expression) - 0usize];
    ["Offset of field: StatementData::returnExpression"][::std::mem::offset_of!(StatementData, returnExpression) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Statement {
    pub data: StatementData,
    pub type_: StatementType,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Statement"][::std::mem::size_of::<Statement>() - 96usize];
    ["Alignment of Statement"][::std::mem::align_of::<Statement>() - 8usize];
    ["Offset of field: Statement::data"][::std::mem::offset_of!(Statement, data) - 0usize];
    ["Offset of field: Statement::type_"][::std::mem::offset_of!(Statement, type_) - 88usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct StatementList {
    pub size: ::std::os::raw::c_ulong,
    pub capacity: ::std::os::raw::c_ulong,
    pub data: *mut Statement,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of StatementList"][::std::mem::size_of::<StatementList>() - 24usize];
    ["Alignment of StatementList"][::std::mem::align_of::<StatementList>() - 8usize];
    ["Offset of field: StatementList::size"][::std::mem::offset_of!(StatementList, size) - 0usize];
    ["Offset of field: StatementList::capacity"][::std::mem::offset_of!(StatementList, capacity) - 8usize];
    ["Offset of field: StatementList::data"][::std::mem::offset_of!(StatementList, data) - 16usize];
};
unsafe extern "C" {
    pub fn emptyStatementList(output: *mut StatementList) -> KleinResult;
}
unsafe extern "C" {
    pub fn emptyHeapStatementList(output: *mut *mut StatementList) -> KleinResult;
}
unsafe extern "C" {
    pub fn appendToStatementList(list: *mut StatementList, value: Statement) -> KleinResult;
}
unsafe extern "C" {
    pub fn prependToStatementList(list: *mut StatementList, value: Statement) -> KleinResult;
}
unsafe extern "C" {
    pub fn isStatementListEmpty(list: StatementList) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn popStatementList(list: *mut StatementList) -> KleinResult;
}
unsafe extern "C" {
    pub fn getFromStatementListUnchecked(list: StatementList, index: ::std::os::raw::c_ulong) -> Statement;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BinaryOperator {
    pub precedent: *mut BinaryOperator,
    pub tokenTypes: *mut TokenType,
    pub tokenTypeCount: ::std::os::raw::c_ulong,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of BinaryOperator"][::std::mem::size_of::<BinaryOperator>() - 24usize];
    ["Alignment of BinaryOperator"][::std::mem::align_of::<BinaryOperator>() - 8usize];
    ["Offset of field: BinaryOperator::precedent"][::std::mem::offset_of!(BinaryOperator, precedent) - 0usize];
    ["Offset of field: BinaryOperator::tokenTypes"][::std::mem::offset_of!(BinaryOperator, tokenTypes) - 8usize];
    ["Offset of field: BinaryOperator::tokenTypeCount"][::std::mem::offset_of!(BinaryOperator, tokenTypeCount) - 16usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ForLoop {
    pub binding: *mut ::std::os::raw::c_char,
    pub list: Expression,
    pub body: Block,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ForLoop"][::std::mem::size_of::<ForLoop>() - 96usize];
    ["Alignment of ForLoop"][::std::mem::align_of::<ForLoop>() - 8usize];
    ["Offset of field: ForLoop::binding"][::std::mem::offset_of!(ForLoop, binding) - 0usize];
    ["Offset of field: ForLoop::list"][::std::mem::offset_of!(ForLoop, list) - 8usize];
    ["Offset of field: ForLoop::body"][::std::mem::offset_of!(ForLoop, body) - 80usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct WhileLoop {
    pub condition: Expression,
    pub body: Block,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of WhileLoop"][::std::mem::size_of::<WhileLoop>() - 88usize];
    ["Alignment of WhileLoop"][::std::mem::align_of::<WhileLoop>() - 8usize];
    ["Offset of field: WhileLoop::condition"][::std::mem::offset_of!(WhileLoop, condition) - 0usize];
    ["Offset of field: WhileLoop::body"][::std::mem::offset_of!(WhileLoop, body) - 72usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct IfExpression {
    pub condition: Expression,
    pub body: Block,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IfExpression"][::std::mem::size_of::<IfExpression>() - 88usize];
    ["Alignment of IfExpression"][::std::mem::align_of::<IfExpression>() - 8usize];
    ["Offset of field: IfExpression::condition"][::std::mem::offset_of!(IfExpression, condition) - 0usize];
    ["Offset of field: IfExpression::body"][::std::mem::offset_of!(IfExpression, body) - 72usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IfExpressionList {
    pub size: ::std::os::raw::c_ulong,
    pub capacity: ::std::os::raw::c_ulong,
    pub data: *mut IfExpression,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IfExpressionList"][::std::mem::size_of::<IfExpressionList>() - 24usize];
    ["Alignment of IfExpressionList"][::std::mem::align_of::<IfExpressionList>() - 8usize];
    ["Offset of field: IfExpressionList::size"][::std::mem::offset_of!(IfExpressionList, size) - 0usize];
    ["Offset of field: IfExpressionList::capacity"][::std::mem::offset_of!(IfExpressionList, capacity) - 8usize];
    ["Offset of field: IfExpressionList::data"][::std::mem::offset_of!(IfExpressionList, data) - 16usize];
};
unsafe extern "C" {
    pub fn emptyIfExpressionList(output: *mut IfExpressionList) -> KleinResult;
}
unsafe extern "C" {
    pub fn emptyHeapIfExpressionList(output: *mut *mut IfExpressionList) -> KleinResult;
}
unsafe extern "C" {
    pub fn appendToIfExpressionList(list: *mut IfExpressionList, value: IfExpression) -> KleinResult;
}
unsafe extern "C" {
    pub fn prependToIfExpressionList(list: *mut IfExpressionList, value: IfExpression) -> KleinResult;
}
unsafe extern "C" {
    pub fn isIfExpressionListEmpty(list: IfExpressionList) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn popIfExpressionList(list: *mut IfExpressionList) -> KleinResult;
}
unsafe extern "C" {
    pub fn getFromIfExpressionListUnchecked(list: IfExpressionList, index: ::std::os::raw::c_ulong) -> IfExpression;
}
#[doc = " A program's abstract syntax tree."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Program {
    #[doc = " The statements in the program. The elements in this list are of type `Statement`."]
    pub statements: StatementList,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Program"][::std::mem::size_of::<Program>() - 24usize];
    ["Alignment of Program"][::std::mem::align_of::<Program>() - 8usize];
    ["Offset of field: Program::statements"][::std::mem::offset_of!(Program, statements) - 0usize];
};
unsafe extern "C" {
    #[doc = " Tokenizes the given string of Klein source code into a list of tokens.\n This is the first step of interpreting Klein code.\n\n # Parameters\n\n - `sourceCode` - The original, Klein source code. It may contain\n   syntax and semantic errors and this function will still return `OK`\n   as long as each individual token in the code is a valid Klein token.\n   It mustn't be `NULL`.\n\n - `output` - Where to store the resulting `TokenList`. It must point to\n   some memory (be it stack or heap) that already has enough space to hold\n   a `TokenList`; i.e. it could be the address of stack token or the result of\n   `malloc(sizeof(TokenList))`, but it can't be `NULL`, or an error will be returned.\n   The outputted tokens have copied strings from the original source code (because\n   they need to be null-terminated and the original source code is contiguous),\n   so it's not dependent on `sourceCode` being valid; i.e., if the string stored at\n   `sourceCode` is freed, `output` will still be valid.\n\n # Errors\n\n If memory for the token list fails to allocate, an error is returned.\n If the source code contains unrecognized tokens, an error is returned.\n If the given `sourceCode` or `output` is `NULL`, an error is returned."]
    pub fn tokenizeKlein(sourceCode: *mut ::std::os::raw::c_char, output: *mut TokenList) -> KleinResult;
}
unsafe extern "C" {
    pub fn parseKlein(code: *mut ::std::os::raw::c_char, output: *mut Program) -> KleinResult;
}
unsafe extern "C" {
    pub fn parseKleinExpression(code: *mut ::std::os::raw::c_char, output: *mut Expression) -> KleinResult;
}
unsafe extern "C" {
    pub fn runKlein(code: *mut ::std::os::raw::c_char) -> KleinResult;
}
pub const InternalKey_INTERNAL_KEY_STRING: InternalKey = 0;
pub const InternalKey_INTERNAL_KEY_NUMBER: InternalKey = 1;
pub const InternalKey_INTERNAL_KEY_BOOLEAN: InternalKey = 2;
pub const InternalKey_INTERNAL_KEY_LIST: InternalKey = 3;
pub const InternalKey_INTERNAL_KEY_NULL: InternalKey = 4;
pub const InternalKey_INTERNAL_KEY_FUNCTION: InternalKey = 5;
pub const InternalKey_INTERNAL_KEY_THIS_OBJECT: InternalKey = 6;
pub const InternalKey_INTERNAL_KEY_BUILTIN_FUNCTION: InternalKey = 7;
pub type InternalKey = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Internal {
    pub key: InternalKey,
    pub value: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Internal"][::std::mem::size_of::<Internal>() - 16usize];
    ["Alignment of Internal"][::std::mem::align_of::<Internal>() - 8usize];
    ["Offset of field: Internal::key"][::std::mem::offset_of!(Internal, key) - 0usize];
    ["Offset of field: Internal::value"][::std::mem::offset_of!(Internal, value) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct InternalList {
    pub size: ::std::os::raw::c_ulong,
    pub capacity: ::std::os::raw::c_ulong,
    pub data: *mut Internal,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of InternalList"][::std::mem::size_of::<InternalList>() - 24usize];
    ["Alignment of InternalList"][::std::mem::align_of::<InternalList>() - 8usize];
    ["Offset of field: InternalList::size"][::std::mem::offset_of!(InternalList, size) - 0usize];
    ["Offset of field: InternalList::capacity"][::std::mem::offset_of!(InternalList, capacity) - 8usize];
    ["Offset of field: InternalList::data"][::std::mem::offset_of!(InternalList, data) - 16usize];
};
unsafe extern "C" {
    pub fn emptyInternalList(output: *mut InternalList) -> KleinResult;
}
unsafe extern "C" {
    pub fn emptyHeapInternalList(output: *mut *mut InternalList) -> KleinResult;
}
unsafe extern "C" {
    pub fn appendToInternalList(list: *mut InternalList, value: Internal) -> KleinResult;
}
unsafe extern "C" {
    pub fn prependToInternalList(list: *mut InternalList, value: Internal) -> KleinResult;
}
unsafe extern "C" {
    pub fn isInternalListEmpty(list: InternalList) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn popInternalList(list: *mut InternalList) -> KleinResult;
}
unsafe extern "C" {
    pub fn getFromInternalListUnchecked(list: InternalList, index: ::std::os::raw::c_ulong) -> Internal;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Value {
    pub fields: *mut ValueFieldList,
    pub internals: InternalList,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Value"][::std::mem::size_of::<Value>() - 32usize];
    ["Alignment of Value"][::std::mem::align_of::<Value>() - 8usize];
    ["Offset of field: Value::fields"][::std::mem::offset_of!(Value, fields) - 0usize];
    ["Offset of field: Value::internals"][::std::mem::offset_of!(Value, internals) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ValueList {
    pub size: ::std::os::raw::c_ulong,
    pub capacity: ::std::os::raw::c_ulong,
    pub data: *mut Value,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ValueList"][::std::mem::size_of::<ValueList>() - 24usize];
    ["Alignment of ValueList"][::std::mem::align_of::<ValueList>() - 8usize];
    ["Offset of field: ValueList::size"][::std::mem::offset_of!(ValueList, size) - 0usize];
    ["Offset of field: ValueList::capacity"][::std::mem::offset_of!(ValueList, capacity) - 8usize];
    ["Offset of field: ValueList::data"][::std::mem::offset_of!(ValueList, data) - 16usize];
};
unsafe extern "C" {
    pub fn emptyValueList(output: *mut ValueList) -> KleinResult;
}
unsafe extern "C" {
    pub fn emptyHeapValueList(output: *mut *mut ValueList) -> KleinResult;
}
unsafe extern "C" {
    pub fn appendToValueList(list: *mut ValueList, value: Value) -> KleinResult;
}
unsafe extern "C" {
    pub fn prependToValueList(list: *mut ValueList, value: Value) -> KleinResult;
}
unsafe extern "C" {
    pub fn isValueListEmpty(list: ValueList) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn popValueList(list: *mut ValueList) -> KleinResult;
}
unsafe extern "C" {
    pub fn getFromValueListUnchecked(list: ValueList, index: ::std::os::raw::c_ulong) -> Value;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ValueField {
    pub name: *mut ::std::os::raw::c_char,
    pub value: Value,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ValueField"][::std::mem::size_of::<ValueField>() - 40usize];
    ["Alignment of ValueField"][::std::mem::align_of::<ValueField>() - 8usize];
    ["Offset of field: ValueField::name"][::std::mem::offset_of!(ValueField, name) - 0usize];
    ["Offset of field: ValueField::value"][::std::mem::offset_of!(ValueField, value) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ValueFieldList {
    pub size: ::std::os::raw::c_ulong,
    pub capacity: ::std::os::raw::c_ulong,
    pub data: *mut ValueField,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ValueFieldList"][::std::mem::size_of::<ValueFieldList>() - 24usize];
    ["Alignment of ValueFieldList"][::std::mem::align_of::<ValueFieldList>() - 8usize];
    ["Offset of field: ValueFieldList::size"][::std::mem::offset_of!(ValueFieldList, size) - 0usize];
    ["Offset of field: ValueFieldList::capacity"][::std::mem::offset_of!(ValueFieldList, capacity) - 8usize];
    ["Offset of field: ValueFieldList::data"][::std::mem::offset_of!(ValueFieldList, data) - 16usize];
};
unsafe extern "C" {
    pub fn emptyValueFieldList(output: *mut ValueFieldList) -> KleinResult;
}
unsafe extern "C" {
    pub fn emptyHeapValueFieldList(output: *mut *mut ValueFieldList) -> KleinResult;
}
unsafe extern "C" {
    pub fn appendToValueFieldList(list: *mut ValueFieldList, value: ValueField) -> KleinResult;
}
unsafe extern "C" {
    pub fn prependToValueFieldList(list: *mut ValueFieldList, value: ValueField) -> KleinResult;
}
unsafe extern "C" {
    pub fn isValueFieldListEmpty(list: ValueFieldList) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn popValueFieldList(list: *mut ValueFieldList) -> KleinResult;
}
unsafe extern "C" {
    pub fn getFromValueFieldListUnchecked(list: ValueFieldList, index: ::std::os::raw::c_ulong) -> ValueField;
}
